; -*- mode: scheme -*-

(FPCore (a b c)
 :name "quadp (p42, positive)"
 ;:herbie-expected #f ; Fails in single precision due to bad samples
 :herbie-target
 (let ([sqtD 
  (let ([x (* (sqrt (fabs a)) (sqrt (fabs c)))])
    (let 
      ([acx (if (and (> (fabs a)) (> x 1))
              (* (/ (fabs a) x) (fabs c))
              (* (fabs a)))])
      (let ([acxe (if (and (> (fabs a)) (> x 1))
              (+ (fma (/ (fabs a) x) (- (fabs c)) acx) (* (fma (/ (fabs a) x) x (- (fabs a))) (fabs c)))
              (+ (fma (- (fabs a)) (/ (fabs c) x) acx) (* (fma (/ (fabs c) x) x (- (fabs c))) a)))])
    (let ([dp (- (- (fabs b) x) (/ (- (- acx x) acxe) 2))])
      (if (> dp 0) (* (sqrt dp) (sqrt (+ (fabs b) x)))
      (if (= dp 0) 0
      NAN))))))])
  (if (= sqtD NAN) NAN
    (if (= sqtD 0) (- (/ b (* 2 a)))
    (if (< b 0) (/ (- sqtD (/ b 2)) a)
    (/ (-c) (+ (/ b 2) sqtD))))))

 (let ([d (sqrt (- (* b b) (* 4 (* a c))))])
   (/ (+ (- b) d) (* 2 a))))

(FPCore (a b c)
 :name "quadm (p42, negative)"
 ;:herbie-expected #f ; Fails in single precision due to bad samples
 :herbie-target
 (let ([sqtD 
  (let ([x (* (sqrt (fabs a)) (sqrt (fabs c)))])
    (let 
      ([acx (if (and (> (fabs a)) (> x 1))
              (* (/ (fabs a) x) (fabs c))
              (* (fabs a)))])
      (let ([acxe (if (and (> (fabs a)) (> x 1))
              (+ (fma (/ (fabs a) x) (- (fabs c)) acx) (* (fma (/ (fabs a) x) x (- (fabs a))) (fabs c)))
              (+ (fma (- (fabs a)) (/ (fabs c) x) acx) (* (fma (/ (fabs c) x) x (- (fabs c))) a)))])
    (let ([dp (- (- (fabs b) x) (/ (- (- acx x) acxe) 2))])
      (if (> dp 0) (* (sqrt dp) (sqrt (+ (fabs b) x)))
      (if (= dp 0) 0
      NAN))))))])
  (if (= sqtD NAN) NAN
    (if (= sqtD 0) (- (/ b (* 2 a)))
    (if (< b 0) (/ c (- sqtD (/ b 2)))
    (/ (+ (/ b 2) sqtD) (- a))))))

 (let ([d (sqrt (- (* b b) (* 4 (* a c))))])
   (/ (- (- b) d) (* 2 a))))

(FPCore (a b_2 c)
 :name "quad2m (problem 3.2.1, negative)"
 (let ([sqtD 
  (let ([x (* (sqrt (fabs a)) (sqrt (fabs c)))])
    (let 
      ([acx (if (and (> (fabs a)) (> x 1))
              (* (/ (fabs a) x) (fabs c))
              (* (fabs a)))])
      (let ([acxe (if (and (> (fabs a)) (> x 1))
              (+ (fma (/ (fabs a) x) (- (fabs c)) acx) (* (fma (/ (fabs a) x) x (- (fabs a))) (fabs c)))
              (+ (fma (- (fabs a)) (/ (fabs c) x) acx) (* (fma (/ (fabs c) x) x (- (fabs c))) a)))])
    (let ([dp (- (- (fabs b_2) x) (/ (- (- acx x) acxe) 2))])
      (if (> dp 0) (* (sqrt dp) (sqrt (+ (fabs b_2) x)))
      (if (= dp 0) 0
      NAN))))))])
  (if (= sqtD NAN) NAN
    (if (= sqtD 0) (- (/ b_2 (* 2 a)))
    (if (< b_2 0) (/ c (- sqtD (/ b_2 2)))
    (/ (+ (/ b_2 2) sqtD) (- a))))))

 (let ([d (sqrt (- (* b_2 b_2) (* a c)))])
   (/ (- (- b_2) d) a)))

(FPCore (a b_2 c)
 :name "quad2p (problem 3.2.1, positive)"
  (let ([sqtD 
  (let ([x (* (sqrt (fabs a)) (sqrt (fabs c)))])
    (let 
      ([acx (if (and (> (fabs a)) (> x 1))
              (* (/ (fabs a) x) (fabs c))
              (* (fabs a)))])
      (let ([acxe (if (and (> (fabs a)) (> x 1))
              (+ (fma (/ (fabs a) x) (- (fabs c)) acx) (* (fma (/ (fabs a) x) x (- (fabs a))) (fabs c)))
              (+ (fma (- (fabs a)) (/ (fabs c) x) acx) (* (fma (/ (fabs c) x) x (- (fabs c))) a)))])
    (let ([dp (- (- (fabs b_2) x) (/ (- (- acx x) acxe) 2))])
      (if (> dp 0) (* (sqrt dp) (sqrt (+ (fabs b_2) x)))
      (if (= dp 0) 0
      NAN))))))])
  (if (= sqtD NAN) NAN
    (if (= sqtD 0) (- (/ b_2 (* 2 a)))
    (if (< b_2 0) (/ (- sqtD (/ b_2 2)) a)
    (/ (-c) (+ (/ b_2 2) sqtD))))))

 (let ([d (sqrt (- (* b_2 b_2) (* a c)))])
   (/ (+ (- b_2) d) a)))
