; -*- mode: scheme -*-

(FPCore (a b c)
 :name "quadp (p42, positive) v1"
 ;:herbie-expected #f ; Fails in single precision due to bad samples
 :herbie-target
 (let* ((t_0 (cbrt (* c a))) (t_1 (* -4.0 (pow t_0 2.0))))
   (if (<= b -1e+150)
     (- (/ c b) (/ b a))
     (if (<= b 0)
       (/ (- (sqrt (- (* b b) (* 4.0 (* c a)))) b) (* a 2.0))
       (if (<= b 1e+13)
         (/
          (/
           (+ (* t_0 t_1) (* b (* b 0.0)))
           (+ b (sqrt (fma t_1 t_0 (* b b)))))
          (* a 2.0))
         (/ (- c) b)))))

 (let ([d (sqrt (- (* b b) (* 4 (* a c))))])
   (/ (+ (- b) d) (* 2 a))))

(FPCore (a b c)
 :name "quadp (p42, positive) v2"
 ;:herbie-expected #f ; Fails in single precision due to bad samples
 :herbie-target
  (if (<= b -1e+150)
    (/ (- b) a)
    (if (<= b 0)
      (/ (- (sqrt (fma b b (* c (* a (- 4))))) b) (* a 2))
      (/ (- c) b)))

 (let ([d (sqrt (- (* b b) (* 4 (* a c))))])
   (/ (+ (- b) d) (* 2 a))))

(FPCore (a b c)
 :name "quadm (p42, negative)"
 ;:herbie-expected #f ; Fails in single precision due to bad samples
 :herbie-target
 (let ([sqtD 
  (let ([x (* (sqrt (fabs a)) (sqrt (fabs c)))])
    (let 
      ([acx (if (and (> (fabs a)) (> x 1))
              (* (/ (fabs a) x) (fabs c))
              (* (fabs a)))])
      (let ([acxe (if (and (> (fabs a)) (> x 1))
              (+ (fma (/ (fabs a) x) (- (fabs c)) acx) (* (fma (/ (fabs a) x) x (- (fabs a))) (fabs c)))
              (+ (fma (- (fabs a)) (/ (fabs c) x) acx) (* (fma (/ (fabs c) x) x (- (fabs c))) a)))])
    (let ([dp (- (- (fabs b) x) (/ (- (- acx x) acxe) 2))])
      (if (> dp 0) (* (sqrt dp) (sqrt (+ (fabs b) x)))
      (if (== dp 0) 0
      NAN))))))])
  (if (== sqtD NAN) NAN
    (if (== sqtD 0) (- (/ b (* 2 a)))
    (if (< b 0) (/ c (- sqtD (/ b 2)))
    (/ (+ (/ b 2) sqtD) (- a))))))

 (let ([d (sqrt (- (* b b) (* 4 (* a c))))])
   (/ (- (- b) d) (* 2 a))))

(FPCore (a b_2 c)
 :name "quad2m (problem 3.2.1, negative)"
 :herbie-target
 (let ([sqtD 
  (let ([x (* (sqrt (fabs a)) (sqrt (fabs c)))])
    (let 
      ([acx (if (and (> (fabs a)) (> x 1))
              (* (/ (fabs a) x) (fabs c))
              (* (fabs a)))])
      (let ([acxe (if (and (> (fabs a)) (> x 1))
              (+ (fma (/ (fabs a) x) (- (fabs c)) acx) (* (fma (/ (fabs a) x) x (- (fabs a))) (fabs c)))
              (+ (fma (- (fabs a)) (/ (fabs c) x) acx) (* (fma (/ (fabs c) x) x (- (fabs c))) a)))])
    (let ([dp (- (- (fabs b_2) x) (/ (- (- acx x) acxe) 2))])
      (if (> dp 0) (* (sqrt dp) (sqrt (+ (fabs b_2) x)))
      (if (== dp 0) 0
      NAN))))))])
  (if (== sqtD NAN) NAN
    (if (== sqtD 0) (- (/ b_2 (* 2 a)))
    (if (< b_2 0) (/ c (- sqtD (/ b_2 2)))
    (/ (+ (/ b_2 2) sqtD) (- a))))))

 (let ([d (sqrt (- (* b_2 b_2) (* a c)))])
   (/ (- (- b_2) d) a)))

(FPCore (a b_2 c)
 :name "quad2p (problem 3.2.1, positive)"
 :herbie-target
  (let ([sqtD 
    (let ([x (* (sqrt (fabs a)) (sqrt (fabs c)))])
      (let 
        ([acx (if (and (> (fabs a)) (> x 1))
                (* (/ (fabs a) x) (fabs c))
                (* (fabs a)))])
        (let ([acxe (if (and (> (fabs a)) (> x 1))
                (+ (fma (/ (fabs a) x) (- (fabs c)) acx) (* (fma (/ (fabs a) x) x (- (fabs a))) (fabs c)))
                (+ (fma (- (fabs a)) (/ (fabs c) x) acx) (* (fma (/ (fabs c) x) x (- (fabs c))) a)))])
      (let ([dp (- (- (fabs b_2) x) (/ (- (- acx x) acxe) 2))])
        (if (> dp 0) (* (sqrt dp) (sqrt (+ (fabs b_2) x)))
        (if (== dp 0) 0
        NAN))))))])
  (if (== sqtD NAN) NAN
    (if (== sqtD 0) (- (/ b_2 (* 2 a)))
    (if (< b_2 0) (/ (- sqtD (/ b_2 2)) a)
    (/ (- c) (+ (/ b_2 2) sqtD))))))

  (let ([d (sqrt (- (* b_2 b_2) (* a c)))])
    (/ (+ (- b_2) d) a)))
