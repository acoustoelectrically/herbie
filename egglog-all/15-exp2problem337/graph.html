<!doctype html>
<html><head><meta charset="utf-8"/><title>Result for exp2 (problem 3.3.7)</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" integrity="sha384-9tPv11A+glH/on/wEu99NVwDPwkMQESOocs/ZGXPoIiLE8MU/qkqUcZ3zzL+6DuH" crossorigin="anonymous"/><script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.js" integrity="sha384-U8Vrjwb8fuHMt6ewaCy8uqeUXv4oitYACKdB0VziCerzt011iQ/0TqlSlv8MReCm" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/contrib/auto-render.min.js" integrity="sha384-aGfk5kvhIq5x1x5YdvCp4upKZYnA8ckafviDpmWEKp4afOZEqOli7gqSnh8I6enH" crossorigin="anonymous"></script><script src="https://unpkg.com/mathjs@4.4.2/dist/math.min.js"></script><script src="https://unpkg.com/d3@6.7.0/dist/d3.min.js"></script><script src="https://unpkg.com/@observablehq/plot@0.4.3/dist/plot.umd.min.js"></script><link rel="stylesheet" type="text/css" href="../report.css"/><script src="../report.js"></script></head><body><header><h1>exp2 (problem 3.3.7)</h1><img src="../logo-car.png"/><nav><ul><li><a href="../index.html">Report</a></li><li><a href="timeline.html">Metrics</a></li></ul></nav></header><div id="large"><div>Percentage Accurate: <span class="number" title="Minimum Accuracy: 1.7% → 3.3%">53.6%<span class="unit"> → </span>53.6%</span></div><div>Time: <span class="number">13.6s</span></div><div>Alternatives: <span class="number">5</span></div><div>Speedup: <span class="number" title="Relative speed of fastest alternative that improves accuracy.">1.0×</span></div></div><section><details id="specification" class="programs"><summary><h2>Specification</h2><select><option>Math</option><option>FPCore</option><option>C</option><option>Fortran</option><option>Java</option><option>Python</option><option>Julia</option><option>MATLAB</option><option>Wolfram</option><option>TeX</option></select><a class="help-button float" href="https://herbie.uwplse.org/doc/2.2/report.html#spec" target="_blank">?</a></summary><div><div id="precondition"><div class="program math">\[\left|x\right| \leq 710\]</div></div><div class="implementation" data-language="Math"><div class="program math">\[\begin{array}{l}

\\
\left(e^{x} - 2\right) + e^{-x}
\end{array}
\]</div></div><div class="implementation" data-language="FPCore"><pre class="program">
(FPCore (x) :precision binary64 (+ (- (exp x) 2.0) (exp (- x))))</pre></div><div class="implementation" data-language="C"><pre class="program">
double code(double x) {
	return (exp(x) - 2.0) + exp(-x);
}
</pre></div><div class="implementation" data-language="Fortran"><pre class="program">
real(8) function code(x)
    real(8), intent (in) :: x
    code = (exp(x) - 2.0d0) + exp(-x)
end function
</pre></div><div class="implementation" data-language="Java"><pre class="program">
public static double code(double x) {
	return (Math.exp(x) - 2.0) + Math.exp(-x);
}
</pre></div><div class="implementation" data-language="Python"><pre class="program">
def code(x):
	return (math.exp(x) - 2.0) + math.exp(-x)
</pre></div><div class="implementation" data-language="Julia"><pre class="program">
function code(x)
	return Float64(Float64(exp(x) - 2.0) + exp(Float64(-x)))
end
</pre></div><div class="implementation" data-language="MATLAB"><pre class="program">
function tmp = code(x)
	tmp = (exp(x) - 2.0) + exp(-x);
end
</pre></div><div class="implementation" data-language="Wolfram"><pre class="program">
code[x_] := N[(N[(N[Exp[x], $MachinePrecision] - 2.0), $MachinePrecision] + N[Exp[(-x)], $MachinePrecision]), $MachinePrecision]
</pre></div><div class="implementation" data-language="TeX"><pre class="program">\begin{array}{l}

\\
\left(e^{x} - 2\right) + e^{-x}
\end{array}
</pre></div></div><p>Sampling outcomes in <kbd>binary64</kbd> precision:</p><div class="bogosity"><div class="bogosity-valid" data-id="bogosity-valid" data-type="valid" data-timespan="0.5040950775146484" title="valid (50.4%)"></div><div class="bogosity-unknown" data-id="bogosity-unknown" data-type="unknown" data-timespan="0" title="unknown (0.0%)"></div><div class="bogosity-infinite" data-id="bogosity-infinite" data-type="infinite" data-timespan="0" title="infinite (0.0%)"></div><div class="bogosity-unsamplable" data-id="bogosity-unsamplable" data-type="unsamplable" data-timespan="0" title="unsamplable (0.0%)"></div><div class="bogosity-invalid" data-id="bogosity-invalid" data-type="invalid" data-timespan="0.0" title="invalid (0.0%)"></div><div class="bogosity-precondition" data-id="bogosity-precondition" data-type="precondition" data-timespan="0.49590492248535156" title="precondition (49.6%)"></div></div></details></section><figure id="graphs"><h2>Local Percentage Accuracy vs <span id="variables"></span><a class="help-button float" href="https://herbie.uwplse.org/doc/2.2/report.html#graph" target="_blank">?</a></h2><svg></svg><div id="functions"></div><figcaption>The average percentage accuracy by input value. Horizontal axis shows value of an input variable; the variable is choosen in the title. Vertical axis is accuracy; higher is better. Red represent the original program, while blue represents Herbie's suggestion. These can be toggled with buttons below the plot. The line is an average while dots represent individual samples.</figcaption></figure><section id="cost-accuracy" class="section" data-benchmark-name="exp2 (problem 3.3.7)"><h2>Accuracy vs Speed<a class="help-button float" href="https://herbie.uwplse.org/doc/2.2/report.html#cost-accuracy" target="_blank">?</a></h2><div class="figure-row"><svg></svg><div><p>Herbie found 5 alternatives:</p><table><thead><tr><th>Alternative</th><th class="numeric">Accuracy</th><th class="numeric">Speedup</th></tr></thead><tbody></tbody></table></div></div><figcaption>The accuracy (vertical axis) and speed (horizontal axis) of each alternatives. Up and to the right is better. The red square shows the initial program, and each blue circle shows an alternative.The line shows the best available speed-accuracy tradeoffs.</figcaption></section><section id="initial" class="programs"><h2>Initial Program: <span class="subhead"><data>53.6%</data> accurate, <data>1.0×</data> speedup</span><select><option>Math</option><option>FPCore</option><option>C</option><option>Fortran</option><option>Java</option><option>Python</option><option>Julia</option><option>MATLAB</option><option>Wolfram</option><option>TeX</option></select><a class="help-button float" href="https://herbie.uwplse.org/doc/2.2/report.html#alternatives" target="_blank">?</a></h2><div><div class="implementation" data-language="Math"><div class="program math">\[\begin{array}{l}

\\
\left(e^{x} - 2\right) + e^{-x}
\end{array}
\]</div></div><div class="implementation" data-language="FPCore"><pre class="program">
(FPCore (x) :precision binary64 (+ (- (exp x) 2.0) (exp (- x))))</pre></div><div class="implementation" data-language="C"><pre class="program">
double code(double x) {
	return (exp(x) - 2.0) + exp(-x);
}
</pre></div><div class="implementation" data-language="Fortran"><pre class="program">
real(8) function code(x)
    real(8), intent (in) :: x
    code = (exp(x) - 2.0d0) + exp(-x)
end function
</pre></div><div class="implementation" data-language="Java"><pre class="program">
public static double code(double x) {
	return (Math.exp(x) - 2.0) + Math.exp(-x);
}
</pre></div><div class="implementation" data-language="Python"><pre class="program">
def code(x):
	return (math.exp(x) - 2.0) + math.exp(-x)
</pre></div><div class="implementation" data-language="Julia"><pre class="program">
function code(x)
	return Float64(Float64(exp(x) - 2.0) + exp(Float64(-x)))
end
</pre></div><div class="implementation" data-language="MATLAB"><pre class="program">
function tmp = code(x)
	tmp = (exp(x) - 2.0) + exp(-x);
end
</pre></div><div class="implementation" data-language="Wolfram"><pre class="program">
code[x_] := N[(N[(N[Exp[x], $MachinePrecision] - 2.0), $MachinePrecision] + N[Exp[(-x)], $MachinePrecision]), $MachinePrecision]
</pre></div><div class="implementation" data-language="TeX"><pre class="program">\begin{array}{l}

\\
\left(e^{x} - 2\right) + e^{-x}
\end{array}
</pre></div></div></section><section id="alternative1" class="programs"><h2>Alternative 1: <span class="subhead"><data>53.6%</data> accurate, <data>0.9×</data> speedup</span><select><option>Math</option><option>FPCore</option><option>C</option><option>Fortran</option><option>Java</option><option>Python</option><option>Julia</option><option>MATLAB</option><option>Wolfram</option><option>TeX</option></select><a class="help-button float" href="https://herbie.uwplse.org/doc/2.2/report.html#alternatives" target="_blank">?</a></h2><div><div class="implementation" data-language="Math"><div class="program math">\[\begin{array}{l}
x_m = \left|x\right|

\\
\begin{array}{l}
t_0 := e^{-x\_m}\\
\left(\frac{1}{t\_0} - 2\right) + t\_0
\end{array}
\end{array}
\]</div></div><div class="implementation" data-language="FPCore"><pre class="program">x_m = (fabs.f64 x)
(FPCore (x_m)
 :precision binary64
 (let* ((t_0 (exp (- x_m)))) (+ (- (/ 1.0 t_0) 2.0) t_0)))</pre></div><div class="implementation" data-language="C"><pre class="program">x_m = fabs(x);
double code(double x_m) {
	double t_0 = exp(-x_m);
	return ((1.0 / t_0) - 2.0) + t_0;
}
</pre></div><div class="implementation" data-language="Fortran"><pre class="program">x_m = abs(x)
real(8) function code(x_m)
    real(8), intent (in) :: x_m
    real(8) :: t_0
    t_0 = exp(-x_m)
    code = ((1.0d0 / t_0) - 2.0d0) + t_0
end function
</pre></div><div class="implementation" data-language="Java"><pre class="program">x_m = Math.abs(x);
public static double code(double x_m) {
	double t_0 = Math.exp(-x_m);
	return ((1.0 / t_0) - 2.0) + t_0;
}
</pre></div><div class="implementation" data-language="Python"><pre class="program">x_m = math.fabs(x)
def code(x_m):
	t_0 = math.exp(-x_m)
	return ((1.0 / t_0) - 2.0) + t_0
</pre></div><div class="implementation" data-language="Julia"><pre class="program">x_m = abs(x)
function code(x_m)
	t_0 = exp(Float64(-x_m))
	return Float64(Float64(Float64(1.0 / t_0) - 2.0) + t_0)
end
</pre></div><div class="implementation" data-language="MATLAB"><pre class="program">x_m = abs(x);
function tmp = code(x_m)
	t_0 = exp(-x_m);
	tmp = ((1.0 / t_0) - 2.0) + t_0;
end
</pre></div><div class="implementation" data-language="Wolfram"><pre class="program">x_m = N[Abs[x], $MachinePrecision]
code[x$95$m_] := Block[{t$95$0 = N[Exp[(-x$95$m)], $MachinePrecision]}, N[(N[(N[(1.0 / t$95$0), $MachinePrecision] - 2.0), $MachinePrecision] + t$95$0), $MachinePrecision]]
</pre></div><div class="implementation" data-language="TeX"><pre class="program">\begin{array}{l}
x_m = \left|x\right|

\\
\begin{array}{l}
t_0 := e^{-x\_m}\\
\left(\frac{1}{t\_0} - 2\right) + t\_0
\end{array}
\end{array}
</pre></div></div><details><summary>Derivation</summary><ol class="history"><li><p>Initial program <span class="error" title="53.6% on training set">53.4%</span></p><div class="math">\[\left(e^{x} - 2\right) + e^{-x}
\]</div></li><li>Add Preprocessing</li><li></li><li><p>Applied rewrites<span class="error" title="53.6% on training set">53.4%</span></p><div class="math">\[\leadsto \left(\color{blue}{\frac{1}{e^{-x}}} - 2\right) + e^{-x}
\]</div></li><li>Add Preprocessing</li></ol></details></section><section id="alternative2" class="programs"><h2>Alternative 2: <span class="subhead"><data>53.6%</data> accurate, <data>1.0×</data> speedup</span><select><option>Math</option><option>FPCore</option><option>C</option><option>Fortran</option><option>Java</option><option>Python</option><option>Julia</option><option>MATLAB</option><option>Wolfram</option><option>TeX</option></select><a class="help-button float" href="https://herbie.uwplse.org/doc/2.2/report.html#alternatives" target="_blank">?</a></h2><div><div class="implementation" data-language="Math"><div class="program math">\[\begin{array}{l}
x_m = \left|x\right|

\\
\left(e^{x\_m} - 2\right) + \frac{1}{e^{x\_m}}
\end{array}
\]</div></div><div class="implementation" data-language="FPCore"><pre class="program">x_m = (fabs.f64 x)
(FPCore (x_m) :precision binary64 (+ (- (exp x_m) 2.0) (/ 1.0 (exp x_m))))</pre></div><div class="implementation" data-language="C"><pre class="program">x_m = fabs(x);
double code(double x_m) {
	return (exp(x_m) - 2.0) + (1.0 / exp(x_m));
}
</pre></div><div class="implementation" data-language="Fortran"><pre class="program">x_m = abs(x)
real(8) function code(x_m)
    real(8), intent (in) :: x_m
    code = (exp(x_m) - 2.0d0) + (1.0d0 / exp(x_m))
end function
</pre></div><div class="implementation" data-language="Java"><pre class="program">x_m = Math.abs(x);
public static double code(double x_m) {
	return (Math.exp(x_m) - 2.0) + (1.0 / Math.exp(x_m));
}
</pre></div><div class="implementation" data-language="Python"><pre class="program">x_m = math.fabs(x)
def code(x_m):
	return (math.exp(x_m) - 2.0) + (1.0 / math.exp(x_m))
</pre></div><div class="implementation" data-language="Julia"><pre class="program">x_m = abs(x)
function code(x_m)
	return Float64(Float64(exp(x_m) - 2.0) + Float64(1.0 / exp(x_m)))
end
</pre></div><div class="implementation" data-language="MATLAB"><pre class="program">x_m = abs(x);
function tmp = code(x_m)
	tmp = (exp(x_m) - 2.0) + (1.0 / exp(x_m));
end
</pre></div><div class="implementation" data-language="Wolfram"><pre class="program">x_m = N[Abs[x], $MachinePrecision]
code[x$95$m_] := N[(N[(N[Exp[x$95$m], $MachinePrecision] - 2.0), $MachinePrecision] + N[(1.0 / N[Exp[x$95$m], $MachinePrecision]), $MachinePrecision]), $MachinePrecision]
</pre></div><div class="implementation" data-language="TeX"><pre class="program">\begin{array}{l}
x_m = \left|x\right|

\\
\left(e^{x\_m} - 2\right) + \frac{1}{e^{x\_m}}
\end{array}
</pre></div></div><details><summary>Derivation</summary><ol class="history"><li><p>Initial program <span class="error" title="53.6% on training set">53.4%</span></p><div class="math">\[\left(e^{x} - 2\right) + e^{-x}
\]</div></li><li>Add Preprocessing</li><li></li><li><p>Applied rewrites<span class="error" title="53.6% on training set">53.4%</span></p><div class="math">\[\leadsto \left(e^{x} - 2\right) + \color{blue}{\frac{1}{e^{x}}}
\]</div></li><li>Add Preprocessing</li></ol></details></section><section id="alternative3" class="programs"><h2>Alternative 3: <span class="subhead"><data>53.5%</data> accurate, <data>1.0×</data> speedup</span><select><option>Math</option><option>FPCore</option><option>C</option><option>Fortran</option><option>Java</option><option>Python</option><option>Julia</option><option>MATLAB</option><option>Wolfram</option><option>TeX</option></select><a class="help-button float" href="https://herbie.uwplse.org/doc/2.2/report.html#alternatives" target="_blank">?</a></h2><div><div class="implementation" data-language="Math"><div class="program math">\[\begin{array}{l}
x_m = \left|x\right|

\\
e^{x\_m} - \left(2 - e^{-x\_m}\right)
\end{array}
\]</div></div><div class="implementation" data-language="FPCore"><pre class="program">x_m = (fabs.f64 x)
(FPCore (x_m) :precision binary64 (- (exp x_m) (- 2.0 (exp (- x_m)))))</pre></div><div class="implementation" data-language="C"><pre class="program">x_m = fabs(x);
double code(double x_m) {
	return exp(x_m) - (2.0 - exp(-x_m));
}
</pre></div><div class="implementation" data-language="Fortran"><pre class="program">x_m = abs(x)
real(8) function code(x_m)
    real(8), intent (in) :: x_m
    code = exp(x_m) - (2.0d0 - exp(-x_m))
end function
</pre></div><div class="implementation" data-language="Java"><pre class="program">x_m = Math.abs(x);
public static double code(double x_m) {
	return Math.exp(x_m) - (2.0 - Math.exp(-x_m));
}
</pre></div><div class="implementation" data-language="Python"><pre class="program">x_m = math.fabs(x)
def code(x_m):
	return math.exp(x_m) - (2.0 - math.exp(-x_m))
</pre></div><div class="implementation" data-language="Julia"><pre class="program">x_m = abs(x)
function code(x_m)
	return Float64(exp(x_m) - Float64(2.0 - exp(Float64(-x_m))))
end
</pre></div><div class="implementation" data-language="MATLAB"><pre class="program">x_m = abs(x);
function tmp = code(x_m)
	tmp = exp(x_m) - (2.0 - exp(-x_m));
end
</pre></div><div class="implementation" data-language="Wolfram"><pre class="program">x_m = N[Abs[x], $MachinePrecision]
code[x$95$m_] := N[(N[Exp[x$95$m], $MachinePrecision] - N[(2.0 - N[Exp[(-x$95$m)], $MachinePrecision]), $MachinePrecision]), $MachinePrecision]
</pre></div><div class="implementation" data-language="TeX"><pre class="program">\begin{array}{l}
x_m = \left|x\right|

\\
e^{x\_m} - \left(2 - e^{-x\_m}\right)
\end{array}
</pre></div></div><details><summary>Derivation</summary><ol class="history"><li><p>Initial program <span class="error" title="53.6% on training set">53.4%</span></p><div class="math">\[\left(e^{x} - 2\right) + e^{-x}
\]</div></li><li>Add Preprocessing</li><li></li><li><p>Applied rewrites<span class="error" title="53.5% on training set">53.4%</span></p><div class="math">\[\leadsto \color{blue}{e^{x} - \left(2 - e^{-x}\right)}
\]</div></li><li>Add Preprocessing</li></ol></details></section><section id="alternative4" class="programs"><h2>Alternative 4: <span class="subhead"><data>53.6%</data> accurate, <data>1.0×</data> speedup</span><select><option>Math</option><option>FPCore</option><option>C</option><option>Fortran</option><option>Java</option><option>Python</option><option>Julia</option><option>MATLAB</option><option>Wolfram</option><option>TeX</option></select><a class="help-button float" href="https://herbie.uwplse.org/doc/2.2/report.html#alternatives" target="_blank">?</a></h2><div><div class="implementation" data-language="Math"><div class="program math">\[\begin{array}{l}
x_m = \left|x\right|

\\
\left(e^{x\_m} - 2\right) + e^{-x\_m}
\end{array}
\]</div></div><div class="implementation" data-language="FPCore"><pre class="program">x_m = (fabs.f64 x)
(FPCore (x_m) :precision binary64 (+ (- (exp x_m) 2.0) (exp (- x_m))))</pre></div><div class="implementation" data-language="C"><pre class="program">x_m = fabs(x);
double code(double x_m) {
	return (exp(x_m) - 2.0) + exp(-x_m);
}
</pre></div><div class="implementation" data-language="Fortran"><pre class="program">x_m = abs(x)
real(8) function code(x_m)
    real(8), intent (in) :: x_m
    code = (exp(x_m) - 2.0d0) + exp(-x_m)
end function
</pre></div><div class="implementation" data-language="Java"><pre class="program">x_m = Math.abs(x);
public static double code(double x_m) {
	return (Math.exp(x_m) - 2.0) + Math.exp(-x_m);
}
</pre></div><div class="implementation" data-language="Python"><pre class="program">x_m = math.fabs(x)
def code(x_m):
	return (math.exp(x_m) - 2.0) + math.exp(-x_m)
</pre></div><div class="implementation" data-language="Julia"><pre class="program">x_m = abs(x)
function code(x_m)
	return Float64(Float64(exp(x_m) - 2.0) + exp(Float64(-x_m)))
end
</pre></div><div class="implementation" data-language="MATLAB"><pre class="program">x_m = abs(x);
function tmp = code(x_m)
	tmp = (exp(x_m) - 2.0) + exp(-x_m);
end
</pre></div><div class="implementation" data-language="Wolfram"><pre class="program">x_m = N[Abs[x], $MachinePrecision]
code[x$95$m_] := N[(N[(N[Exp[x$95$m], $MachinePrecision] - 2.0), $MachinePrecision] + N[Exp[(-x$95$m)], $MachinePrecision]), $MachinePrecision]
</pre></div><div class="implementation" data-language="TeX"><pre class="program">\begin{array}{l}
x_m = \left|x\right|

\\
\left(e^{x\_m} - 2\right) + e^{-x\_m}
\end{array}
</pre></div></div><details><summary>Derivation</summary><ol class="history"><li><p>Initial program <span class="error" title="53.6% on training set">53.4%</span></p><div class="math">\[\left(e^{x} - 2\right) + e^{-x}
\]</div></li><li>Add Preprocessing</li><li>Add Preprocessing</li></ol></details></section><section id="alternative5" class="programs"><h2>Alternative 5: <span class="subhead"><data>51.0%</data> accurate, <data>209.0×</data> speedup</span><select><option>Math</option><option>FPCore</option><option>C</option><option>Fortran</option><option>Java</option><option>Python</option><option>Julia</option><option>MATLAB</option><option>Wolfram</option><option>TeX</option></select><a class="help-button float" href="https://herbie.uwplse.org/doc/2.2/report.html#alternatives" target="_blank">?</a></h2><div><div class="implementation" data-language="Math"><div class="program math">\[\begin{array}{l}
x_m = \left|x\right|

\\
0
\end{array}
\]</div></div><div class="implementation" data-language="FPCore"><pre class="program">x_m = (fabs.f64 x)
(FPCore (x_m) :precision binary64 0.0)</pre></div><div class="implementation" data-language="C"><pre class="program">x_m = fabs(x);
double code(double x_m) {
	return 0.0;
}
</pre></div><div class="implementation" data-language="Fortran"><pre class="program">x_m = abs(x)
real(8) function code(x_m)
    real(8), intent (in) :: x_m
    code = 0.0d0
end function
</pre></div><div class="implementation" data-language="Java"><pre class="program">x_m = Math.abs(x);
public static double code(double x_m) {
	return 0.0;
}
</pre></div><div class="implementation" data-language="Python"><pre class="program">x_m = math.fabs(x)
def code(x_m):
	return 0.0
</pre></div><div class="implementation" data-language="Julia"><pre class="program">x_m = abs(x)
function code(x_m)
	return 0.0
end
</pre></div><div class="implementation" data-language="MATLAB"><pre class="program">x_m = abs(x);
function tmp = code(x_m)
	tmp = 0.0;
end
</pre></div><div class="implementation" data-language="Wolfram"><pre class="program">x_m = N[Abs[x], $MachinePrecision]
code[x$95$m_] := 0.0
</pre></div><div class="implementation" data-language="TeX"><pre class="program">\begin{array}{l}
x_m = \left|x\right|

\\
0
\end{array}
</pre></div></div><details><summary>Derivation</summary><ol class="history"><li><p>Initial program <span class="error" title="53.6% on training set">53.4%</span></p><div class="math">\[\left(e^{x} - 2\right) + e^{-x}
\]</div></li><li>Add Preprocessing</li><li></li><li><p>Applied rewrites<span class="error" title="53.5% on training set">53.3%</span></p><div class="math">\[\leadsto \color{blue}{\left(e^{-x} + e^{x}\right) - 2}
\]</div></li><li></li><li><p>Applied rewrites<span class="error" title="51.0% on training set">50.1%</span></p><div class="math">\[\leadsto \color{blue}{0}
\]</div></li><li>Add Preprocessing</li></ol></details></section><section id="target1" class="programs"><h2>Developer Target 1: <span class="subhead"><data>99.9%</data> accurate, <data>0.9×</data> speedup</span><select><option>Math</option><option>FPCore</option><option>C</option><option>Fortran</option><option>Java</option><option>Python</option><option>Julia</option><option>MATLAB</option><option>Wolfram</option><option>TeX</option></select><a class="help-button float" href="https://herbie.uwplse.org/doc/2.2/report.html#target" target="_blank">?</a></h2><div><div class="implementation" data-language="Math"><div class="program math">\[\begin{array}{l}

\\
\begin{array}{l}
t_0 := \sinh \left(\frac{x}{2}\right)\\
4 \cdot \left(t\_0 \cdot t\_0\right)
\end{array}
\end{array}
\]</div></div><div class="implementation" data-language="FPCore"><pre class="program">
(FPCore (x)
 :precision binary64
 (let* ((t_0 (sinh (/ x 2.0)))) (* 4.0 (* t_0 t_0))))</pre></div><div class="implementation" data-language="C"><pre class="program">
double code(double x) {
	double t_0 = sinh((x / 2.0));
	return 4.0 * (t_0 * t_0);
}
</pre></div><div class="implementation" data-language="Fortran"><pre class="program">
real(8) function code(x)
    real(8), intent (in) :: x
    real(8) :: t_0
    t_0 = sinh((x / 2.0d0))
    code = 4.0d0 * (t_0 * t_0)
end function
</pre></div><div class="implementation" data-language="Java"><pre class="program">
public static double code(double x) {
	double t_0 = Math.sinh((x / 2.0));
	return 4.0 * (t_0 * t_0);
}
</pre></div><div class="implementation" data-language="Python"><pre class="program">
def code(x):
	t_0 = math.sinh((x / 2.0))
	return 4.0 * (t_0 * t_0)
</pre></div><div class="implementation" data-language="Julia"><pre class="program">
function code(x)
	t_0 = sinh(Float64(x / 2.0))
	return Float64(4.0 * Float64(t_0 * t_0))
end
</pre></div><div class="implementation" data-language="MATLAB"><pre class="program">
function tmp = code(x)
	t_0 = sinh((x / 2.0));
	tmp = 4.0 * (t_0 * t_0);
end
</pre></div><div class="implementation" data-language="Wolfram"><pre class="program">
code[x_] := Block[{t$95$0 = N[Sinh[N[(x / 2.0), $MachinePrecision]], $MachinePrecision]}, N[(4.0 * N[(t$95$0 * t$95$0), $MachinePrecision]), $MachinePrecision]]
</pre></div><div class="implementation" data-language="TeX"><pre class="program">\begin{array}{l}

\\
\begin{array}{l}
t_0 := \sinh \left(\frac{x}{2}\right)\\
4 \cdot \left(t\_0 \cdot t\_0\right)
\end{array}
\end{array}
</pre></div></div></section><section id="reproduce"><details><summary><h2>Reproduce</h2><a class="help-button float" href="https://herbie.uwplse.org/doc/2.2/report.html#reproduction" target="_blank">?</a></summary><pre class="shell"><code>herbie shell --seed 1494275546 
(FPCore (x)
  :name "exp2 (problem 3.3.7)"
  :precision binary64
  :pre (&lt;= (fabs x) 710.0)

  :alt
  (! :herbie-platform default (* 4 (* (sinh (/ x 2)) (sinh (/ x 2)))))

  (+ (- (exp x) 2.0) (exp (- x))))
</code></pre></details></section></body></html>