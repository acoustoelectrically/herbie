<html><head></head><body><p>
The Herbie API allows applications to interface with Herbie using HTTP requests. The API is designed to be context-free; the order in which endpoints are called shouldn't matter.
</p>



<pre class="prettyprint">/api/sample
</pre>


<p>
Input:
</p>
<pre>
{
	formula: &lt;FPCore expression&gt;,
	seed: &lt;random seed for point generation&gt;
}
</pre>
<p>
Response:
</p>
<pre>
{
	points: [[point, exact], . ]
}
</pre>
<p>
The <code>sample</code> endpoint allows the user to request a sample of points given the FPCore expression and a seed. 
</p>
<p>
Returns a collection of points and the exact evaluation of each point with the given spec. The results are returned through the .points. field and are represented by an array of point-exact pairs with the first value representing the point and the second value representing the exact evaluation; the exact value of point <code>n</code> is <code>points[n][1]</code>.
</p>
<p>
Herbie calculates the .ground truth. by calculating the values with more precise numbers. This can be slow.
</p>



<pre class="prettyprint">/api/exacts
</pre>


<p>
Input:
</p>
<pre>
{
	formula: &lt;FPCore expression&gt;,
	points: [point . ]
}
</pre>
<p>
Response:
</p>
<pre>
{
	points: [[point, exact], . ]
}
</pre>
<p>
The <code>exacts</code> endpoint allows the user to request the exact value of a set of points evaluated at a real number specification given as an FPCore expression.
</p>
<p>
Some points may not be calculable given the FPCore expression.
</p>
<p>
Returns a collection of points and the exact evaluation of each point with the given spec. The results are returned through the .points. field and are represented by an array of point-exact pairs with the first value representing the point and the second value representing the exact evaluation; the exact value of point <code>n</code> is <code>points[n][1]</code>.
</p>
<p>
Herbie calculates the .ground truth. by calculating the values with more precise numbers. This can be slow.
</p>



<pre class="prettyprint">/api/calculate
</pre>


<p>
Input:
</p>
<pre>
{
	formula: &lt;FPCore expression&gt;,
	points: [point . ]
}
</pre>
<p>
Response:
</p>
<pre>
{
	points: [[point, exact], . ]
}
</pre>
<p>
The <code>calculate</code> endpoint allows the user to request the evaluation of a set of points evaluated at a floating-point implementation given as an FPCore expression.
</p>
<p>
Some points may not be calculable given the FPCore expression.
</p>
<p>
Returns a collection of points and the evaluation of each point using the given FPCore as a floating-point implementation. The results are returned through the .points. field and are represented by an array of point-exact pairs with the first value representing the point and the second value representing the evaluated value; the evaluated value of point <code>n</code> is <code>points[n][1]</code>.
</p>



<pre class="prettyprint">/api/analyze
</pre>


<p>
Input:
</p>
<pre>
{
	formula: &lt;FPCore expression&gt;,
	points: [[point, exact], . ]
}
</pre>
<p>
Response:
</p>
<pre>
{
	points: [[point, error], . ]
}
</pre>
<p>
The <code>analyze</code> endpoint allows the user to request error analysis of a set of point-exact pairs and a given floating-point implementation.
</p>
<p>
Given a collection of points, their exact values, and an FPCore expression to analyze on, the <code>analyze</code> endpoint returns the error for each point for that expression. The error value returned is Herbie.s internal error heuristic.
</p>



<pre class="prettyprint">/api/alternatives
</pre>


<p>
Input:
</p>

<pre>
{
	formula: &lt;FPCore expression&gt;,
	points: [[point, exact], . ]
}
</pre>

<p>
Response:
</p>

<pre>
{
	alternatives: [alt, . ],
	histories: [history, . ],
	splitpoints: [splitpoint, . ]
}
</pre>

<p>
The <code>alternatives</code> endpoint allows the user to request rewrites from Herbie given an expression to rewrite and a set of point-exact pairs.
</p>
<p>
Returns a list of alternatives represented by FPCore expressions through the .alternatives. field. 
</p>
<p>
Returns a list of derivations of each alternative through the .histories. field where <code>history[n]</code> corresponds to <code>alternatives[n]</code>.
</p>
<p>
Returns a list of splitpoints for each alternative through the .histories. field where <code>splitpoints[n]</code> corresponds to <code>alternatives[n]</code>. <code>splitpoints[n]</code> will only contain information about the corresponding alternative.s splitpoints if the alternative is a branch-expression.
</p>



<pre class="prettyprint">/api/mathjs
</pre>


<p>
Input:
</p>
<pre>
{
	formula: &lt;FPCore expression&gt;
}
</pre>
<p>
Response:
</p>
<pre>
{
	mathjs: &lt;mathjs expression&gt;
}
</pre>
<p>
The <code>mathjs</code> endpoint allows the user to translate FPCore expressions into mathjs expressions.
</p>
</body></html>
